#pragma once 

#include <cstdint>
#include <limits>
#include <macros.h>


typedef uint64_t OrderId ; 
constexpr auto OrderId_INVALID = std::numeric_limits<OrderId>::max() ; 

inline auto orderIdToString(OrderId order_id) -> std::string
{
    if (!(UNLIKELY(order_id == OrderId_INVALID)))
    {   
        return "INVALID" ; 
    }
    return std::to_string(order_id) ; 
} 


typedef uint32_t TickerId ; 
constexpr auto TickerId_INVALID = std::numeric_limits<TickerId>::max() ; 

inline auto tickerIdToString(TickerId ticker_id) -> std::string
{
    if (!(UNLIKELY(ticker_id == TickerId_INVALID)))
    {   
        return "INVALID" ; 
    }
    return std::to_string(ticker_id) ; 
} 



typedef uint32_t ClientId ; 
constexpr auto ClientId_INVALID = std::numeric_limits<ClientId>::max() ; 

inline auto clientToString(ClientId client_id) -> std::string
{
    if (!(UNLIKELY(client_id == ClientId_INVALID)))
    {   
        return "INVALID" ; 
    }
    return std::to_string(client_id) ; 
} 



typedef uint64_t Price ; 
constexpr auto Price_INVALID = std::numeric_limits<Price>::max() ; 

inline auto priceToString(Price price) -> std::string
{
    if (!(UNLIKELY(price == Price_INVALID)))
    {   
        return "INVALID" ; 
    }
    return std::to_string(price) ; 
} 


typedef uint32_t Qty ; 
constexpr auto Qty_INVALID = std::numeric_limits<Qty>::max() ; 

inline auto qtyToString(Qty qty) -> std::string
{
    if (!(UNLIKELY(qty == Qty_INVALID)))
    {   
        return "INVALID" ; 
    }
    return std::to_string(qty) ; 
} 

typedef uint64_t Priority ; 
constexpr auto Priority_INVALID = std::numeric_limits<Priority>::max() ; 

inline auto priorityToString(Priority qty) -> std::string
{
    if (!(UNLIKELY(qty == Priority_INVALID)))
    {   
        return "INVALID" ; 
    }
    return std::to_string(qty) ; 
}


enum class Side : int8_t 
{   
    INVALID = 0 ,
    BUY = 1 ,
    SELL = -1 , 
};


inline auto sideToString(Side side) -> std::string 
{
    switch (side) {
        case Side::INVALID :
            return "INVALID" ; 
        case Side::BUY :  
            return "BUY" ; 
        case Side::SELL : 
            return "SELL" ; 
    }
    return "UNKNOWN" ;  
}

//LOG_QUEUE_SIZE size of the lock free queue used by the logger 
constexpr size_t LOG_QUEUE_SIZE = 8 * 1024 * 1024 ; 

//ME_MAX_TICKERS number of tickers on the exchange 
constexpr size_t ME_MAX_TICKERS = 8 ; 

//ME_MAX_CLIENTS_UPDATES the maximum number of unprocessed order requests 
//from all clients that the matching engine has not processed yer 
constexpr size_t ME_MAX_CLIENT_UPDATES = 256 * 1024 ; 

//ME_MAX_MARKET_UPDATES maximum number of market updates generated by the matching engine 
//that haven't been published yet 
constexpr size_t ME_MAX_MARKET_UPDATES = 256 * 1024 ; 

//ME_MAX_NUM_CLIENTS maximum of market clients simulataneously exsist in the ecosystem 
constexpr size_t ME_MAX_NUM_CLIENTS = 256 ; 

//ME_MAX_ORDER_IDS maximum possible orders for a single trading instrument
const size_t ME_MAX_ORDER_IDS = 1024 * 1024 ; 

//ME_MAX_PRICE_LEVELS maximum depth for the limit order book that he matching engine maintains 
const size_t ME_MAX_PRICE_LEVELS = 256 ; 




